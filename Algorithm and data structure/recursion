A recursive function should have the following properties so that it does not result in an infinite loop:

1. A simple base case (or cases) â€” a terminating scenario that does not use recursion to produce an answer.
2. A set of rules, also known as recurrence relation that reduces all other cases towards the base case.

In this article we will look closer into the duplicate calculations problem that could happen with recursion.
We will then propose a common technique called memoization that can be used to avoid this problem.

To eliminate the duplicate calculation in the above case, as many of you would have figured out, 
one of the ideas would be to store the intermediate results in the cache so that we could reuse them later without re-calculation.

Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function
calls and returning the cached result when the same inputs occur again. 

Back to our Fibonacci function F(n). We could use a hash table to keep track of the result of each F(n) with n as the key. The hash
table serves as a cache that saves us from duplicate calculations. The memoization technique is a good example that demonstrates 
how one can reduce compute time in exchange for some additional space.

import java.util.HashMap;

public class Main {

  HashMap<Integer, Integer> cache = new HashMap<Integer, Integer>();

  private int fib(int N) {
    if (cache.containsKey(N)) {
      return cache.get(N);
    }
    int result;
    if (N < 2) {
      result = N;
    } else {
      result = fib(N-1) + fib(N-2);
    }
    // keep the result in cache.
    cache.put(N, result);
    return result;
  }
}
................................................................................
Time Complexity - Recursion
Given a recursion algorithm, its time complexity O(T) is typically the product of the number of recursion invocations (denoted as R)
and the time complexity of calculation (denoted as O(s)) that incurs along with each recursion call:

O(T) = R * O(s)

Fibonacci number: f(n) = f(n-1) + f(n - 2)
The execution tree of a recursive function would form an n-ary tree, with n as the number of times recursion appears in the recurrence relation.

Space Complexity - Recursion

Recursion Related Space + Non-Recursion Related Space
Non-Recursion Related Space: which typically includes the space (normally in heap) that is allocated for the global variables.
...............................................................................

Tail recursion is a recursion where the recursive call is the final instruction in the recursion function. And there should be 
only one recursive call in the function.

public class Main {
    
  private static int helper_non_tail_recursion(int start, int [] ls) {
    if (start >= ls.length) {
      return 0;
    }
    // not a tail recursion because it does some computation after the recursive call returned.
    return ls[start] + helper_non_tail_recursion(start+1, ls);
  }

  public static int sum_non_tail_recursion(int [] ls) {
    if (ls == null || ls.length == 0) {
      return 0;
    }
    return helper_non_tail_recursion(0, ls);
  }

  //---------------------------------------------

  private static int helper_tail_recursion(int start, int [] ls, int acc) {
    if (start >= ls.length) {
      return acc;
    }
    // this is a tail recursion because the final instruction is the recursive call.
    return helper_tail_recursion(start+1, ls, acc+ls[start]);
  }
    
  public static int sum_tail_recursion(int [] ls) {
    if (ls == null || ls.length == 0) {
      return 0;
    }
    return helper_tail_recursion(0, ls, 0);
  }
}

The benefit of having tail recursion is that it could avoid the accumulation of stack overheads during the recursive calls, 
since the system could reuse a fixed amount space in the stack for each recursive call. 

A tail recursion function can be executed as non-tail-recursion functions, i.e. with piles of call stacks, without impact on the result. Often, the compiler recognizes tail recursion pattern, and optimizes its execution. However, not all programming languages support this optimization. For instance, C, C++ support the optimization of tail recursion functions. On the other hand, Java and Python do not support tail recursion optimization.
.....................................................................................................

1. write down the recurrence relationship.

2. Whenever possible, apply memoization.

3. When stack overflows, tail recursion might come to help. 

